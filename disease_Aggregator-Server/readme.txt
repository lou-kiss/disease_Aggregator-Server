Θεόδωρος Λούκης
1115201500083
3η Εργασία Προγραμματισμός Συστήματος 2019-20
sdi1500083@di.uoa.gr

Σχολιασμός Εργασίας

Ενδεικτικες εκτελέσεις προγραμμάτων :

./master -i input_dir -p 1100 -s 192.168.1.104 -w 7 -b 1024
./whoClient -q queries.txt -w 2 -sp 2222 -sip 192.168.1.104
./whoServer -q 2222 -s 1100 -w 5 -b 11

Ξεκινωντας η εφαρμογη master αφου διαβασει τα arguments με την βoηθεια της συναρτησης checkArgs που εχει δωσει ο χρηστης και εφοσον τα arguments ειναι σωστα, ανοιγει το input_dir ωστε να υπολογισει το συνολο των χωρων που βρισκονται μεσα. Στην συνεχεια ανοιγει το directory καθε χωρας μεσα στο input_dir ωστε να υπολογίσει το σύνολο των αρχείων ημερομηνίας. Αφου γίνει ο υπολογισμός αυτός, η εφαρμογή χωρίζει ομοίμορφα πόσες χώρες θα πάρει κάθε worker και φτίαχνει ένα string στο οποίο χωρίζει τις χώρες με # πχ (#Greece#USA#UK). Στην περίπτωση που οι χώρες είναι λιγότερες από τους numWorkers που θελει ο χρήστης να φτιάξουμε η εφαρμογή μειώνει το αριθμό των numWorkers σε country_count (=αριθμο χωρων στο input_dir) ωστε να μην φτιάξουμε παραπάνω διεργασίες απο ότι χρειαζόμαστε. Ο master φτιάχνει numWorkers*2 named pipes (με την βοήθεια της συνάρτησης makeFifos), ενα pipe για να γράφει στο κάθε παιδί και ένα για να του γράφει το κάθε παιδί και στην συνέχεια δημιουργεί numWorkers παιδία κάνοντας fork() και κάθε παιδι που δημιουργειτε καλει την συνάρτηση workerFunc που βρισκεται στο source file worker.c . Μετά ανοίγει τα namedpipes με την συνάρτηση openFifos και στέλνει σε κάθε worker τις χώρες του. Στη συνέχεια περιμένει να τερματίσει καποιο παιδι ωστε να κάνει handle το σημα SIGCHLD. 

Όταν δημιουργειτε ένας worker, αρχικά ανοίγει τα pipes του για να διαβάσει τις χώρες που του έχει στείλει o diseaseAggregator. Στην συνέχεια εμφανίζει ένα μήνυμα με το pid του το pid_count του [0-(nuMWorkers-1)] και τις χώρες που έλαβε απο τον πατέρα του αποκωδικοποιημένες. Μέτα δεσμέυει δυναμικά μνήμη για τους HashTables που θα χρησιμοποιήσει για την αποθήευση των recordID's (mainHashTable) και των ασθενειών (diseaseHashTable) και στελνει μεσω socket στον whoServer καποιες σηματικες πληροφοριες για την συνεχεια ( το workerPort του, τον αριθμο των workers, το workerCount του και ποιες χωρες εχει αναλαβει). Σε αυτο το σημειό να τονίσω ότι έχουν χρησιμοποιηθεί οι δομές της 1ης εργασίας όπως και η λογική τους και σε μερικά σημεία έχουν γίνει οι κατάλληλες τροποποιήσεις για να καλύπτουν τις απαιτήσεις της άσκησης. Αφού ανοίξουμε το directory κάθε χώρας αποθηκεύουμε σε ένα πίνακα τα αρχεία ημερομηνίας που βρίσκονται σε κάθε country directory κ μετά τα ταξινομούμε χρονολογικά με χρήση της συνάρτησης ChronOrder. Ανοίγουμε κάθε αρχείο ημερομηνίας σε αύξουσα σειρά, αποθηκεύουμε τους ασθενείς στον πίνακα mainHashTable όπου <<κατακερματίζονται>> με βάση το recordID τους και στην συνέχεια υπολογίζουμε τα summary statistics κάθε αρχείου τα οποία στέλνονται socket στον whoServer. Αφού ο worker ανοίξει όλα τα αρχεία του και περάσει όλους τους ασθενείς στο mainHashTable (με εξαίρεση τα error records) κάθε worker περνάει τα δεδομένα του mainHashTable στον diseaseHashTable και στέλνει μεσω socket στον whoServer ένα μήνυμα FIN (τελος στα γαλλικα) με σκοπο ο server να σταματησει να διαβαζει απο αυτο το file desciptor του socket καθως τα στατιστικα και οι πληροφοριες τελειωσαν. Στην συνέχεια καθε worker ακουει στο worker port του (1030+workerCounter, δηλαδη ο 1ος worker θα εχει port: 1030+0=1030) για συνδεσεις απο τον whoServer που θα περιεχουν queries. Ο κάθε worker βρισκει την απαντηση σε καθε query και την στελνει πισω στον whoServer. 

Ξεκινωντας ο whoServer δημιουργει numThreads Threads και ανοιγει 2 sockets. Θα ακουει στην θυρα 1111 για συνδεσεις απο τους worker και στην θυρα 2222 για συνδεσεις απο τον client. Οι 2 αυτες θυρες μπορουν να διαφερουν αναλογα τις τιμες που θα δωσει ο χρηστης. Στην συνεχεια χρησιμοποιουμε την select() για να κανουμε monitor τα 2 sockets. Οποτε δεχτει καποια συνδεσει ο server γινεται accept και ο file descriptor που επιστρεφει η accept εισαγεται σε ενα κυκλικο buffer μεγεθους bufferSize. Για την υλοποιηση του κυκλικου buffer εχω χρησιμοποιησει την δομη 
circleBuffer. Τα threads κατα την δημιουργια τους εκτελουν την συναρτηση threadFunc η οποια μπλοκαρει οταν ο κυκλικος buffer ειναι αδειος. Με το που μπει εστω και 1 file descriptor στον buffer ενα thread "ξυπναει" και καλειται η συναρτηση handle_connection μεσω της οποιας ενα thread διαβαζει 1. τις πληροφοριες καθε worker και τις εμφανιζει 2. διαβαζει τα στατιστικα (χωρις να τα εμφανισει) 3. και αν του εχει σταλει καποιο query απο τον client το επεξεργαζεται με την συναρτηση handle query. H συναρτηση αυτη διαβαζει το query και εφοσον ειναι valid εντολη( μια απο τις 5 που ζητουνται) την στελνει στον worker μεσω της συναρτησης sendQueryToWorkers και περιμενει να διαβασει το αποτελεσμα του query το οποιο στην συνεχεια στελνει στον client. 

Ο whoClient αφοτου διαβασει τα arguments του χρηστη μετραει ποσες γραμμες εχει το query.txt file και καπου εδω κανουμε την εξης παραδοχη: ο client δημιουργει oσα threads ειναι και οι γραμμες του αρχειου ετσι ωστε καθε thread να παρει απο μια γραμμη και ολες οι γραμμες του αρχειου να σταλθουν ταυτοχρονα. Στην συνεχεια δημιουργει τα threads τα οποια περιμενουν το τελευταιο thread να δημιουργηθει και να τους κανει broadcast το condition variable που τα κραταει να περιμενουν. Στην συνεχεια στελνουν ολα μαζι το query τους στον server λαμβανουν την απαντηση την εμφανιζουν και τερματιζουν!
